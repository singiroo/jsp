@RequestMapping : 요청 처리할 컨트롤러의 메소드를 지정.
 설정된 url 패턴에 의해 메소드 지정.

사용위치 : 1. class
		 2. method
		 
@Controller
@RequestMapping(path="/mainPath")
public class xxxController {

	@RequestMapping(path="/subPath")
	public String subPath() {
	}

	@RequestMapping(path="/subPath2")
	public String subPath2() {
	}
	
}

/mainPath/subPath ==> xxController.subPath();
/mainPath/subPath2 ==> xxController.subPath2();

@RequestMapping  속성
* path : url 패턴(default : 속성명을 따로 지정하지 않아도 알아서 path로 인식.)
		 그러나 추가적인 속성을 사용할 때는 반드시 path 속성을 명시해야함.

* method : 요청 메소드에 따라 설정한 요청에 대해서만 처리하게끔 한정.
		   method = {"RequestMethod.GET, RequestMethod.POST, ..."}
		   
	@RequestMethod(path="login/view", method={"RequestMethod.GET, RequestMethod.POST"})

 	또는
		method 별로 나눠진 Mapping 어노테이션 사용
		@GetMapping
	  	@PostMapping
	  	...

* params : 파라미터중에 특정 값을 갖거나, 파라미터가 존재하는 등 파라미터와 관련된 조건을 기술
           ex)
        	@RequestMapping(params = {"userId"}) : userId 파라미터가 존재할 때 요청을 처리.
        	@RequestMapping(params = {"!userId"}) : userId 파라미터가 존재하지 않을 때 요청 처리.  
        	@RequestMapping(params = {"pass == brownPass"}) : pass 파라미터가 전송되었고 그 값이 brownPass와 일치할 때 요청 처리.  
        	@RequestMapping(params = {"pass != brownPass"}) : pass 파라미터가 전송되었으나 그 값이 brownPass와 일치하지 않을 때 요청 처리.  

        
* header : 요청 헤더에 특정 값이 담겨있을 때만 요청 처리
* consume - Content-type : 클라이언트에서 보낸 요청의 컨텐츠 타입
* produce - Accept Header : 클라이언트에서 받길 요청하는 컨텐츠 타입 = 서버에서 생성할 응답의 컨텐츠 타입
							요청 컨텐츠 타입에 따라 요청 처리 (**ajax 수업시 다시 함)

<스프링 컨트롤러 메소드의 인자 : 서블릿과 다르게 정해진 규칙 안에서 자유롭게 인자를 설정 할 수 있다.>

1. Servlet api : HttpServletRequest, HttpServletResponse, HttpSession
	public String method(HttpServletRequest request){
		HttpSession session = request.getSession();
		session.setAttribute("S_MEMBER", ....);
	}
	 => session을 얻기 위해서 request가 필요.
	
	public String method(HttpSession session){
		session.setAttribute("S_MEMBER", ....);
	}
	 => HttpSession 객체만 이용. 스프링 프레임워크가 빈을 주입해줌.
	 
2. command 객체(=form 객체 : form 전송을 통해 전달된 파라미터를 담는 객체 - Value Object)

3. 파라미터를 담은 개별 변수 (String userid, String pass)

파라미터 name 과 메서드의 인자 이름 및 command 객체의 필드명이 일치해야 바인딩이 됨.

3.5 bindingResult : 바인딩 결과를 담는 객체 - 추후 validation 수업시 진행

4. model/ModelMap/map : 속성을 저장할 객체 (servlet의 request에 해당.)	

5. RedirectAttributes : 리다이렉트 페이지에서 사용할 1회용 속성을 설정. 세션을 이용
		redirectAttributes.addFlashAttribute(1회용 속성 설정)
		redirectAttributes.addAttribute
		
<부수적 인자>	
+. HttpMethod : post, get(잘안씀)
+. Principal : Spring Security에서 사용하는 사용자 인증 정보


<스프링 컨트롤러에서 사용할 수 있는 어노테이션>

* @RequestParam : 파라미터 이름과 값을 담을 변수 명이 다를 때 파라미터를 특정 변수에 할당 할 수 있다.
				기본 값 설정, 
				**command 객체 필드에서는 사용 못함**.
				
				사용방법 : 컨트롤러 메소드의 인자에 설정
				
				name : 전송받은 파라미터의 이름
				required : 파라미터 존재(필수) 유무 설정, 기본은 true				
           				   required가 true일 때 해당 파라미터가 전송되지 않으면 에러
           				   required가 false일 때 해당 파라미터가 전송되지 않으면 null
           
* @RequestPart : multipart/form-data의 파트를 받아옴.
				 
				 
				 

* @RequestHeader, @CookieValue : 요청시 사용된 헤더, 쿠키값을 파라미터 인자에서 받을 수 있다.

* @PathVariable : 패스변수
				@RequestMapping에 설정된 url 경로중 일부를 파라미터 인자로 받아온다.
				ex)
				/notice/ct
				/notice/sk
				같은 페이지이지만 데이터만 다를 때?
				@RequestMapping("/notice/{library}")
					public String notice(@PathVariable("library") String library)
					{
					}


<스프링 컨트롤러의 리턴 타입>

1. String : 논리적인 viewName을 의미
            ViewResolver에 의해 처리할 view를 결정하여 처리, 많이 사용되는 형태
2. ModelAndView : 스프링 컨테이너는 응답 생성을 위해 내부적으로 ModelAndView 객체를 생성 하여 처리하는데 그 과정을 개발자가 직접 하는 것.

3. void : servlet과 같은 형태, outputstream, writer 객체를 통해 응답을 직접 생성하는 경우, 	  
		  image 응답을 생성하는 controller 생성(추후 실습 내용)

4. View : 응답을 처리할 View객체를 직접 개발자가 명시

@ModelAttribute 
	메소드에서 사용시 : 1. @RequestMapping 어노테이션이 붙은 메소드가 실행되기 전에 항상 먼저 실행.
					2. 해당 메소드(@ModelAttribute 어노테이션 설정된 메서드)에서 리턴하는 값을 Model 객체에 자동으로 설정.
	메소드 인자에서 사용시 : public String methodName(@ModelAttribute("rangers") List<String> rangers) {
						}
						메소드 인자로 Model 객체를 선언하지 않고도(비어있는 객체(객체 자체가 null은 아니나 객체 안에 데이터가 모두 null)를 만들어줌)
						모델에 설정된 속성을 메소드 인자에서 받을 수 있다. 자동으로 바인딩.
						
@SessionAttributes : class레벨에 적용.
   					 설정한 속성을 session에 저장하여
   					 @ModelAttribute 어노테이션이 붙은 메소드가 요청시마다 실행되는 것을 방지한다.
   					 
   					=> 해당 메서드(@ModelAttribute 설정 메서드)는 최초 1번만 실행되고 model을 session에 저장하여 해당 메서드는
   					   이후 session이 만료될때까지 실행되지 않는다. 
   					 
   					 
   					 
   					 
   					 
						